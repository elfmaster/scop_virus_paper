The future of ELF parasite infection techniques with SCOP binaries

-= Introduction

With the recent introduction of SCOP (Secure code partitioning) security
mitigation, or otherwise known as the 'ld -separate-code' feature there are
naturally going to be some changes in the way ELF segments are parsed, and more
thought provoking is how malware authors will infect them. I intend to
extrapolate on all of the methods that come to mind when I look at the way
these ELF binaries are linked.	Pre-requisite reading [1] will be useful and I
will assume the reader has a complete understanding of the SCOP binary
mitigation before jumping right into 'infection techniques for parisitic code',
which could also be termed 'injection techniques' for innovative
instrumentation depending on the motives.

-= A quick primer on the text segment layout

In traditional executables the loadable segments tradtionally look
like the ascii illustration 1.0 below.

--ELF Illustration 1.0

              PT_LOAD 0		PT_LOAD 1
[text_segment(R+X)][data_segment(R+W)]

And all of the readonly data which doesn't require execution, such as the
.rodata section, .rela.* sections, and the dynamic symbol table .dynsym/.dynstr
are stored in the read-only part of the executable which is the text segment; a
read-only executable segment. If one gives a close observation though it
becomes quickly apparent that there are only four or five sections in the text
segment that actually require execution, and the linker marks them respectively
with the section_header->sh_flags value being set to SHF_ALLOC|SHF_EXECINSTR,
whereas the sections that are read-only are marked as SHF_ALLOC, meaning they
are allocated into memory, and that's it.

Here is the output of 'readelf -S' on a 32bit executable, we examine only the
sections that are in the text segment, I have truncated the rest of the output.

  [ 0]			 NULL		 00000000 000000 000000 00	0   0  0
  [ 1] .interp		 PROGBITS	 08048154 000154 000013 00   A	0   0  1
  [ 2] .note.ABI-tag	 NOTE		 08048168 000168 000020 00   A	0   0  4
  [ 3] .note.gnu.build-i NOTE		 08048188 000188 000024 00   A	0   0  4
  [ 4] .gnu.hash	 GNU_HASH	 080481ac 0001ac 000020 04   A	5   0  4
  [ 5] .dynsym		 DYNSYM		 080481cc 0001cc 000060 10   A	6   1  4
  [ 6] .dynstr		 STRTAB		 0804822c 00022c 000050 00   A	0   0  1
  [ 7] .gnu.version	 VERSYM		 0804827c 00027c 00000c 02   A	5   0  2
  [ 8] .gnu.version_r	 VERNEED	 08048288 000288 000020 00   A	6   1  4
  [ 9] .rel.dyn		 REL		 080482a8 0002a8 000008 08   A	5   0  4
  [10] .rel.plt		 REL		 080482b0 0002b0 000018 08  AI	5  23  4
  [11] .init		 PROGBITS	 080482c8 0002c8 000023 00  AX	0   0  4
  [12] .plt		 PROGBITS	 080482f0 0002f0 000040 04  AX	0   0 16
  [13] .plt.got		 PROGBITS	 08048330 000330 000008 08  AX	0   0  8
  [14] .text		 PROGBITS	 08048340 000340 0001c2 00  AX	0   0 16
  [15] .fini		 PROGBITS	 08048504 000504 000014 00  AX	0   0  4
  [16] .rodata		 PROGBITS	 08048518 000518 00000f 00   A	0   0  4
  [17] .eh_frame_hdr	 PROGBITS	 08048528 000528 00003c 00   A	0   0  4
  [18] .eh_frame	 PROGBITS	 08048564 000564 0000fc 00   A	0   0  4


Notice that only five sections are requiring execution, the rest are set to
SHF_ALLOC ('A') or in the case of '.rel.plt.' SHF_ALLOC|SHF_INFO_LINK ('AI')
which indicates that the sh_info member links to another section. Now for those
who don't have a full grip on ELF, remember that these section permissions are
only useful for linking code and debugging code at best; however as
demonstrated in the parsing support for SCOP binaries recently merged into
https://github.com/elfmaster/libelfmaster we see that when the section headers
are very useful when heuristically analyzing SCOP binaries with LOAD segments
that have had their p_flags (Memory permissions) modified which is extremely
rare but nonetheless having reliable heuristics is important. Had their
segment permissions tampered with we can rely on the sh_flags of the section
headers to determine whether a binary is a tampered SCOP binary.

NOTE: The astute reader may realize that its possible for an attacker to modify
the section header sh_flags to reflect the segment p_flags.

With SCOP binaries which are illustrated in [1] we no longer have the convention
of a single LOAD segment for the text image. Afterall, why store read-only code
in an executable region when it may contain ROP gadgets? This was a smart move
by the GNU ld and gcc developers. ELF illustration 1.1 shows what a SCOP
binary looks like from the perspective of the program headers.

   PT_LOAD 0	    PT_LOAD 1		PT_LOAD 2	  PT_LOAD 3
[text_segment(R)][text_segment(R+X)][text_segment(R)][data segment(R+W)]

-= Code injection techniques

I see several ways to instrument the binary with a chunk of additional
executable code, while still keeping the ELF headers in-tact. First though
let us discuss very briefly some of the existing infection techniques that
we used, and are discussed in great depth in [2] and [3]

-= Traditional Text segment padding infection

This infection relies on the fact that the text and data segment are flush
against eachother on disk, but since the p_vaddr must be congruent with the
p_offset modulo PAGE_SIZE, we must first extend the p_filesz/p_memsz of the
text segment, and then adjust the p_offset's of the subsequent segments by
shifting forward a PAGE_SIZE, i.e. p_offset += 4096. Please note that this does
not mean that there will be 4096 bytes of useable space for the parasite code,
it means that there will be (data[PT_LOAD].p_vaddr & ~4095) - (text[PT_LOAD].p_vaddr +
text[PT_LOAD].p_memsz); However this limitation is more relevant on 32bit
systems. On x86_64 we can shift the p_offset's that follow the text segment
forward by (parasite_size + 4095 & ~4095) bytes, extending further due to the
fact that x86_64 architecture uses HUGE_PAGES for the elfclass64 binaries
which are 0x200000 bytes in size.

This technique was first conceived (Or atleast published) by Silvio Cesare and
it was brilliant research that impacted me greatly, inspiring my passion as I
delved into the esoteric world of binary formats, and how to meticulously
modify their structure without breaking the format specification that the
kernel requires to be in-tact.

The following illustration shows a traditional text segment padding infection
on disk.

[ehdr][phdr][text:parasite_size_extension(R+X)][PAGE_SIZE][data(R+W)]

This hardly poses a challenge to the adept binary hacker after a brief glance
at the program header table on a SCOP binary we see that the same specification
rules exist, and that there is HUGE_PAGE's being used allowing for much larger
infection sizes on 64bit.

  LOAD		 0x0000000000000000 0x0000000000400000 0x0000000000400000
		 0x00000000000004d0 0x00000000000004d0	R      0x200000
  LOAD		 0x0000000000200000 0x0000000000600000 0x0000000000600000
		 0x000000000000021d 0x000000000000021d	R E    0x200000
  LOAD		 0x0000000000400000 0x0000000000800000 0x0000000000800000
		 0x0000000000000148 0x0000000000000148	R      0x200000

00400000-00401000 r--p 00000000 fd:01 3540930	test_scop_binary
00600000-00601000 r-xp 00200000 fd:01 3540930   test_scop_binary
00800000-00801000 r--p 00400000 fd:01 3540930	test_scop_binary

The text segment is broken up into 3 diferent memory mappings. The end of the
executable mapping (Which is PT_LOAD[1]) is at 0x601000. This virtual address
that begins the 3rd text segment (PT_LOAD[2]) is at 0x8000000, which leaves
quite a bit of space for infection in general.  For injections that require
arbitrary length infections, there are alternative solutions that don't apply
to this paper, see [4], and [5] which both use PT_NOTE to PT_LOAD conversions,
thus allowing them variable length injection size.

-= Text segment padding infection in SCOP binaries

The algorithm used for the existing technique is similar to the original
text segment padding infection except that all phdr->p_offset's after the
first executable LOAD segment: PT_LOAD[1] are adjusted instead of all
phdr->p_offset's after PT_LOAD[0].

Using an example with libelfmaster we will demonstrate the algorithm for
infecting both types of binaries; those which are linked with SCOP and those
that are more traditional.  This should detail the algorithm enough so that
malware authors, virus enthusiasts, and reverse engineers from all walks can
begin infecting SCOP binaries with the historical and brilliant text segment
padding infection concieved by Silvio [3].

NOTE: libelfmaster has some function specifically for handling the text segment
in SCOP binaries: elf_scop_text_filesz, elf_executable_text_base,
elf_executable_text_offset. These are different than the traditional API
functions we also have available: elf_text_filesz, elf_text_base,
elf_text_offset.

... main function, etc. ...

struct elf_segment segment;
elf_segment_iterator_t p_iter;
elfobj_t obj;
bool res, found_text = false;
uint64_t text_vaddr, parasite_vaddr;
size_t parasite_size = SOME_VALUE;

res = elf_open_object(argv[1], &obj,
    ELF_LOAD_F_STRICT|ELF_LOAD_F_MODIFY, &error);
if (res == false) {
	printf("failed: %s\n", elf_error_msg(&error));
	exit(EXIT_FAILURE);
}
elf_segment_iterator_init(&obj, &p_iter);
while (elf_segment_iterator_next(&p_iter, &segment) != NULL) {
	if (elf_flags(&obj, ELF_SCOP_F) == true) {
		/*
		 * elf_executable_text_base() will return the value
		 * of PT_LOAD[1] since it is the part of the text
		 * segments that have executable permissions.
		 */
		if (segment.vaddr == (text_vaddr = elf_executable_text_base(&obj))) {
			struct elf_segment new_text;
			uint64_t parasite_vaddr, old_e_entry, end_of_text;

			parasite_vaddr = segment.vaddr + segment.filesz;
			old_e_entry = elf_entry_point(&obj);
			end_of_text = segment.offset + segment.filesz;
			memcpy(&new_text, &segment, sizeof(segment));
			new_text.filesz += parasite_size;
			new_text.memsz += parasite_size;
			elf_segment_modify(&obj, p_iter.index - 1, &new_text,
			    &error);
			found_text = true;
	} else { /* If this is not a SCOP binary then we just look for the
		  * text segment by finding the first PT_LOAD at a minimum
		  */
		if (segment.offset == 0 && segment.type == PT_LOAD) {
			struct elf_segment new_text;				 
			uint64_t parasite_vaddr, old_e_entry, end_of_text;	 

			text_vaddr = segment.vaddr;
			parasite_vaddr = segment.vaddr + segment.filesz;	 
			old_e_entry = elf_entry_point(&obj);			 
			end_of_text = segment.offset + segment.filesz;		 
			memcpy(&new_text, &segment, sizeof(segment));		 
			new_text.filesz += parasite_size;			 
			new_text.memsz += parasite_size;			 
			elf_segment_modify(&obj, p_iter.index - 1, &new_text,	 
			    &error);						 
			found_text = true;
		}
	}
	if (found_text == true && segment.vaddr > text_vaddr) {
		/*
		 * If we have found the text segment, then we must adjust
		 * the subsequent segment's p_offset's.
		 */
		struct elf_segment new_segment;
		memcpy(&new_segment, &segment, sizeof(segment));
		new_segment.offset += (parasite_size + ((PAGE_SIZE - 1) & ~(PAGE_SIZE - 1));
		elf_segment_modify(&obj, p_iter.index - 1, &new_segment,
		    &error);
	}
	ehdr->e_entry = parasite_vaddr;
	/*
	 * Then of course you must adjust ehdr->e_shoff accordingly
	 * and ehdr->e_entry can point to your parasite code.
	 */
}
... 

-= Traditional reverse text padding infections

A reverse text padding infection, which a good example can be demonstrated in
the Skeksi Virus [6] is the concept of:

1. subtracting the text segment's p_vaddr by PAGE_ALIGN(parasite_len) 

2. extending the size of the text segment by adjusting p_filesz, and p_memsz by
PAGE_ALIGN(parasite_len) bytes

3. shifting the program header table and interp segment forward
PAGE_ALIGN(parasite_len) bytes by adjusting p_offset's accordingly

4. Update elf_hdr->e_shoff, i.e. elf_hdr->e_shoff += PAGE_ALIGN(parasite_len)

5. Update the .text section's offset and address to match where the parasite
begins, i.e. shdr->sh_offset = old_text_base + sizeof(ElfN_Ehdr) 

-= Qualities of a reverse text padding infection

The primary benefits of this infection are that it allows a significantly large
amount of space to inject code in ET_EXEC files. On a 64bit Linux system with
the standard linker script used, an executable has a text base address of
0x400000, thus the maximum parasite length would be 0x400000 -
PAGE_ALIGN_UP(sizeof(ElfN_Ehdr)) = 4.1MB of space. It is also a favorable infection
because it allows the modification of e_entry (Entry point) to point in
the .text section which could potentially circumvent weak Virus heuristics.

The primary disadvantage of this technique is that it will not work with PIE
executables. In theory it could work with SCOP binaries [1] by extending the
2nd PT_LOAD segment in reverse, but as we will see shortly there is a much
better infection technique for regular and PIE executables when SCOP [1] is
being used.

Illustration 1.1

Before infection:

0x400000				    0x600e10
[elf_hdr][phdrs][interp][text_segment(R+X)][data_segment(R+W)]

Illustration 1.2

After infection:

0x3ff000					      0x600e10
[elf_hdr][parasite][phdrs][interp][text_segment(R+X)][data_segment(R+W)]

It could also be visualized in a different way since the text segment
technically begins at the beginning of the file at the 0th offset where elf_hdr
is depicted.

Illustration 1.3

0x3ff000					0x600e10
[reverse text extension <-> original text(R+X)][data segment(R+W)]

-= SCOP Reverse text infections

With SCOP linked binaries we have a theoretical approach. SCOP binaries are by
convention compiled and linked as PIE executable's which pretty much exclude
them from this infection type. There is one theoretical idea if which applied you
should be able to perform the algorithm as it is already laid out, but instead
of reversing PT_LOAD[0] which hase a base address of 0x0, you can reverse the
PT_LOAD[1] segment which is the text segment's R+X code separated segment in
SCOP binaries. With that said, there is a much better infection method for SCOP
binaries that lends itself very nicely to those who want to easily insert large
amounts of code into the target binary without having to make any adjustments
to the ELF file headers.

-= SCOP Ultimate text padding infection

$ gcc -fPIC -pie test.c -o test
$ gcc -fPIC -pie -Wl,-z,separate-code test.c -o test_scop

$ ls -lh test
-rwxrwxr-x 1 elfmaster elfmaster 8.1K Mar 28 13:44 test
$ ls -lh test_scop
-rwxrwxr-x 1 elfmaster elfmaster 4.1M Mar 28 13:44 test_scop
$

Notice that there is an enormous difference in file size for these two
executable's which contain approximately the same amount of code and data. In
the original writeup for SCOP [1] we hadn't yet paid note to this, but it is an
important detail that lends itself very nicely to Virus authors or to those who
want to instrument an executable. Whether or not this was an oversight on the
developers part, I am not entirely sure but no good reason for it has come to
mind. The exact details on why the test_scop is so much larger than test is
because SCOP binaries have p_offset's that are identical to their p_vaddr's for
the first 3 load segments. This is not necessary, because the only requirement
for an executable segment to load is that its p_vaddr and p_offset must be
congruent modulo a PAGE_SIZE. Looking at the first 3 PT_LOAD segments 
we can see that there is a fast amount of space on-disk in between the 1st and 2nd
segment, and in between the 2nd and 3rd segment. The 2nd segment is R+X so this
is ideally the one we want to use. In the test_scop binary the 2nd PT_LOAD segment
has a p_filesz of 0x24d (589 decimal) bytes. The offset of the 3rd segment is at
0x400000. This means that we have an injection space available to us that can be
calculated by PT_LOAD[2].p_offset - PT_LOAD[1].p_offset + PT_LOAD[1].p_filesz.
For the test_scop binary this results in 2096563 bytes of padding length. This
is an unusually large code cave for ELF binary types.

As it turns out the SCOP [1] binary mitigation not only helps tighten down the ROP
gadget regions, but it eases the process of inserting code into the executable.

Illustration 1.4
		PT_LOAD[0]   PT_LOAD[1]			 PT_LOAD[2]    PT_LOAD[3]
[elf_hdr][phdrs][text rdonly][text rd+exec][text-padding][text rdonly][data]

SCOP Ultimate padding Algorithm

1. Insert code into file at PT_LOAD[1].p_offset + PT_LOAD[1].p_filesz
2. Backup original PT_LOAD[1].p_filesz: size_t o_filesz = PT_LOAD[1].p_filesz;
2. Adjust PT_LOAD[1].p_filesz += code_length
3. Modify ehdr->e_entry to point at PT_LOAD[1].p_vaddr + o_filesz


[1] https://www.bitlackeys.org/secure_code_partitioning_2018.txt
[2] Book: Learning Linux binary analysis, chapter 4 'ELF Virus technology'	 
[3] UNIX ELF parasites and viruses http://83.133.184.251/virensimulation.org/lib/vsc01.html
[4] https://github.com/elfmaster/dsym_obfuscate
[5] http://83.133.184.251/virensimulation.org/lib/vrn01.html (Retaliation Virus)
